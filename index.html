<html>
	<title>Linear Regression</title>
	<style>
		body {
			margin: 0px;
			padding: 0px;
			background: #111;
			color: #aaa
		}
		#drop_zone {
			width: 100%;
			height: 100%;
			display: flex;
			justify-content: center;
			align-items: center;
			font-family:'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif
		}
		.chartData {
			position: absolute;
			top: 0;
			left: 0;
			display: block;
		}
		.container {
			position: relative;
			width: 100vw;
		}

		#chartData {
			width: 100vw;

		}
		#chartLine {
			width: 100vw;
			position: absolute;
			top: 0;
			left: 0;
		}
		.secondary {
			display: flex;
		}
		#chartPrecision, #chartMSE {
			width: 49%;
			height: 200px;
		}

		.menubar {
			position: absolute;
			background-color: #222;
			bottom: 0;
			width: 100vw;
			height: 74px;
			display: flex;
			align-items: center;
			text-transform: uppercase;
			font-size: 14px;
		}

		.menubar .text-infos > span {
			font-weight: bold;
		}

		.menubar div {
			width: 100%;
			margin-left: 12px;
			margin-right: 12px;
		}

		.menubar input {
			background-color: #333;
			border: 1px solid #444;
			border-radius: 5px;
			height: 32px;
			width: 100%;
			color: #999;
			padding-left: 24px;
			font-size: 16px;
			padding-top: 4px;
			padding-bottom: 0px;
		}
	</style>
	<script type="text/javascript" src="https://livejs.com/live.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.4/dist/Chart.min.js"></script>
</html>


<div id="drop_zone" ondrop="dropHandler(event);" ondragover="dragOverHandler(event);">
	<div class="chartData">
		<!-- <canvas id="chart1" width="200px" height="200px"></canvas> -->
		<div class="container">
			<canvas id="chartData" height="480"></canvas>
			<canvas id="chartLine" height="480"></canvas>
		</div>

		<div class="secondary">
			<canvas id="chartPrecision"></canvas>
			<canvas id="chartMSE"></canvas>
		</div>

	</div>

	<div class="menubar">
		<div class="text-infos">
			iteration : <span class="iter_curr">--</span> <br />
			time taken (train) : <span class="time_taken">--</span> s <br />
			time taken (+ display): <span class="time_taken_display">--</span> s
		</div>
		<div class="">
			<input 
				ype="number" 
				class="inputIterationsMax" 
				step="1" 
				value="0" 
				oninput="handleChange(event)" 
				onchange="handleChange(event)"/>
		</div>
		<div class="">
			<input 
				type="number" 
				class="inputPrecision" 
				value="0"
				step="0.000001"
				oninput="handleChange(event)" 
				onchange="handleChange(event)"/>
		</div>
		<div class="">
			<input 
				type="number" 
				class="inputLearningRate" 
				value="0" 
				step="0.01"
				oninput="handleChange(event)" 
				onchange="handleChange(event)"/>
		</div>
	</div>
</div>


<script>
	let chartData 			= null,
		chartLine 			= null,
		chartPrecision 		= null,
		chartMSE 			= null

	let len 				= 0

	let worker 				= null,
		max					= [-Infinity, -Infinity],
        min					= [Infinity, Infinity],
		precision			= 0.000001,
		iterations 			= 100000,
		learning_rate 		= 0.01
	
	let precisionHistory 	= [],
		thetasHistory		= [],
		mseHistory			= []

	let inputIterations 	= null,
		inputPrecision 		= null,
		inputLearningRate 	= null,
		spanIterations 		= null,
		spanTimeTaken		= null,
		spanTimeDisplay		= null
	
	let startTime			= 0


	const defaultLineScale = {
						data: [
							{
								x: 1,
								y: 0
							}, 
							{
								x: 0,
								y: 1
							}
						],

						label: 'e',
						borderColor: "#00000011",
						fill: false
					}

	const readDragAndDrop = async (event) => {
		return new Promise((resolve, reject) => {
			const reader = new FileReader();
			reader.onload = function(e2) {
				resolve(e2.target.result)
			}
			reader.onerror = function() {
				reject()
			}
			reader.readAsText(event.dataTransfer.files[0]); 
		})
	}
	
	const initChartData = () => {
		const ctx 	= document.getElementById('chartData').getContext('2d'),
			ctxLine = document.getElementById('chartLine').getContext('2d'),
			ctxPrecision = document.getElementById('chartPrecision').getContext('2d'),
			ctxMSE = document.getElementById('chartMSE').getContext('2d')

		const sharedOptions = {
			options: {
				responsive: false,
				maintainAspectRatio: false,
				legend: {
					display: false
				},
				animation: {
					duration: 0
				},
				hover: {
					animationDuration: 0
				},
				responsiveAnimationDuration: 0,
				scales: {
					xAxes: [{
						type: 'linear',
						position: 'bottom'
					}]
				}
			}
		}

		chartPrecision = new Chart(ctxPrecision, {
			type: 'line',
			data: {
				datasets: []
			},
			...sharedOptions
		});

		chartMSE = new Chart(ctxMSE, {
			type: 'line',
			data: {
				datasets: []
			},
			...sharedOptions
		});

		chartLine = new Chart(ctxLine, {
			type: 'line',
			data: {
				datasets: [defaultLineScale]
			},
			...sharedOptions
		});

		chartData = new Chart(ctx, {
			type: 'scatter',
			data: {
				datasets: [[], []]
			},
			...sharedOptions
		});
	}

	const displayChartData = (data) => {
		chartData.data.datasets[0] = {
			label: 'Scatter',
			data: [...data].map(v => ({x: v[0], y: v[1]})),
			backgroundColor: "#775dd0aa",
			type: "scatter"
		}
		chartData.update()
	}

	async function dropHandler(event) {
		event.preventDefault()
		console.clear()

		spanTimeTaken.innerHTML = "-- "
		startTime = new Date().getTime()

		chartData.data.datasets = [defaultLineScale]
		chartLine.data.datasets = [defaultLineScale]
		chartPrecision.data.datasets = []
		chartMSE.data.datasets = [
			{
				label: ' ',
				data: [],
				borderColor: "#ff4560",
				fill: false
			}
		]

		chartPrecision.update()
		chartMSE.update()

		max	= [-Infinity, -Infinity]
        min	= [Infinity, Infinity]

		let data,
			dataTitle

		const text 	= await readDragAndDrop(event)

		data 		= text.split("\n").map(v => v.split(","))
		dataTitle 	= [data[0][0], data[0][1]]
		data 		= data.slice(1, data.length - 1)


		console.log(data.length)
		len		= data.length * 1.0

		for (const c of data) {
            min[0] = Math.min(min[0], c[0])
            max[0] = Math.max(max[0], c[0])
            min[1] = Math.min(min[1], c[1])
            max[1] = Math.max(max[1], c[1])
        }

    	data = data.map(v => ([
            (v[0] - min[0]) / (max[0] - min[0]),
            (v[1] - min[1]) / (max[1] - min[1]),
        ]))

		displayChartData(data)
		worker.postMessage({action: "START", iterations, learning_rate, precision, data, len})
	}


	function dragOverHandler(event) {
		event.preventDefault()
	}
	

	const denorm = (value, min, max) => {
		return value * (max - min) + min
	}

	const norm = (value, min, max) => {
		return (value - min) / (max - min)
	}

	const pushMSE = (y, x) => {
		if (x < 300 ) {
			chartMSE.data.datasets[0].data.push({y, x})
			chartMSE.update()
		}
	}


	const handleChange = (event) => {
		const { target } = event
		const { value, classList } = target

		switch (classList[0]) {
			case "inputIterationsMax":
				iterations = value
				inputIterations.value = value
				break
			case "inputPrecision":
				precision = value
				inputPrecision.value = value
				break;
			case "inputLearningRate":
				learning_rate = value
				inputLearningRate.value = value
				break;
			default:
				break;
		}
	}

	;(function () {
		initChartData()
		worker = new Worker("train.js")

		//document.querySelector(".iter_total").innerHTML = iterations 
		spanIterations 		= document.querySelector(".iter_curr")
		spanTimeTaken 		= document.querySelector(".time_taken")
		spanTimeDisplay 	= document.querySelector(".time_taken_display")

		inputIterations 	= document.querySelector(".inputIterationsMax")
		inputPrecision 		= document.querySelector(".inputPrecision")
		inputLearningRate 	= document.querySelector(".inputLearningRate")


		inputIterations.value 	= iterations
		inputLearningRate.value = learning_rate
		inputPrecision.value 	= precision

		worker.addEventListener('message', async function(e) {
			if (e.data.action === "ITERATION") {
				precisionHistory.push(e.data.precision)
				mseHistory.push(e.data.mse)



				spanIterations.innerHTML = (e.data.i + 1).toLocaleString("fr")
				spanTimeDisplay.innerHTML = ((new Date().getTime() - startTime) / 1000)
				pushMSE(e.data.mse, e.data.i)



				if (e.data.i < 100 || e.data.i % 500 === 0) {

						chartLine.data.datasets.push ( {
							label: ' ',
							data: [
								{
									x: 0, 
									y: e.data.thetas[0]
								}, 
								{
									x: 1, 
									y: e.data.thetas[0] + e.data.thetas[1]
								}],
								
							borderColor: "#008FFB33",
							type: "line",
							fill: false
						})

						chartLine.update()
					}

			}
			if (e.data.action === "DONE") {
				const { thetas } = e.data
				console.log(min, max)
				console.log("DONE ", e.data.thetas)
				console.log(mseHistory)

				console.log(precisionHistory)

				chartPrecision.data.datasets.push ({
					label: ' ',
					data: [...precisionHistory].slice(0, e.data.iteration * 0.25).map((v, k) => ({y: v[1] + v[0], x: k})),
						
					borderColor: "#feb01955",
					fill: false
				})

				chartPrecision.data.datasets.push ({
					label: ' ',
					data: [...precisionHistory].slice(0, e.data.iteration * 0.25).map((v, k) => ({y: ((v[0]) ), x: k})),
						
					borderColor: "#775dd055",
					fill: false
				})
				chartPrecision.data.datasets.push ({
					label: ' ',
					data: [...precisionHistory].slice(0, e.data.iteration * 0.25).map((v, k) => ({y: (( v[1])), x: k})),
						
					borderColor: "#008ffb55",
					fill: false
				})


				chartPrecision.update()

				spanTimeTaken.innerHTML = (e.data.time_taken / 1000)

				// chartMSE.data.datasets.push ({
				// 	label: ' ',
				// 	data: [...mseHistory].slice(0, e.data.iteration * 0.25).map((v, k) => ({y: v, x: k})),
						
				// 	borderColor: "#ff0000",
				// 	fill: false
				// })
				// chartMSE.update()


				chartData.data.datasets[1] = {
					label: ' ',
					data: [
						{
							x: 0, 
							y: thetas[0]
						}, 
						{
							x: 1, 
							y: thetas[0] + thetas[1]
						}],
						
					borderColor: "#ff0000",
					type: "line",
					fill: false
				}

				chartData.update()

				chartLine.data.datasets[1] = {
					label: ' ',
					data: [
						{
							x: 0, 
							y: thetas[0]
						}, 
						{
							x: 1, 
							y: thetas[0] + thetas[1]
						}],
						
					borderColor: "#ff4560",
					type: "line",
					fill: false
				}

				chartLine.update()

			}
		}, false)
	})()
</script>